
# Java Threads

Java threads provide a powerful mechanism for concurrent programming, allowing multiple tasks to run simultaneously within a single process. This document outlines the basics of Java threads, including how to create, manage, and synchronize them.

## 1. Creating Threads

### Extending the `Thread` class:
You can create a thread by subclassing the `Thread` class and overriding its `run()` method.
```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // Starts the thread
    }
}
```

### Implementing the `Runnable` interface:
Another approach is implementing the `Runnable` interface, which allows more flexibility.
```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start(); // Starts the thread
    }
}
```

## 2. Thread Lifecycle

Threads in Java go through several stages:
- **New**: The thread is created but not started.
- **Runnable**: After calling `start()`, the thread is ready to run.
- **Running**: The thread is executing the `run()` method.
- **Blocked/Waiting**: The thread is waiting for a resource or condition.
- **Terminated**: The thread finishes execution or is stopped.

## 3. Thread Methods

- **`start()`**: Begins thread execution and calls `run()`.
- **`sleep(long millis)`**: Pauses the current thread for a specified time.
- **`join()`**: Allows one thread to wait for another thread to finish.
- **`yield()`**: Suggests the thread scheduler to switch to another thread.
- **`interrupt()`**: Interrupts a thread, potentially throwing an `InterruptedException`.

## 4. Thread Synchronization

When multiple threads access shared resources, synchronization ensures that only one thread accesses the resource at a time.

### Synchronized Block:
```java
synchronized(object) {
    // synchronized code
}
```

### Synchronized Method:
```java
public synchronized void method() {
    // synchronized code
}
```

## 5. Thread Pools

Instead of creating new threads for each task, **thread pools** allow better resource management. Javaâ€™s **ExecutorService** framework helps manage a pool of worker threads efficiently.
```java
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.execute(new RunnableTask());
executor.shutdown();
```

## 6. Concurrency Utilities

Java provides various utilities to handle concurrency more effectively:
- **`CountDownLatch`**: Allows threads to wait for multiple events to complete.
- **`Semaphore`**: Controls access to resources by limiting the number of threads.
- **`ReentrantLock`**: Provides a lock mechanism for synchronization, offering more flexibility than synchronized methods/blocks.

## 7. Daemon Threads

Daemon threads are background threads that perform tasks such as garbage collection. They terminate automatically when all user threads finish.
```java
Thread daemon = new Thread(() -> {
    while (true) {
        System.out.println("Daemon thread running...");
    }
});
daemon.setDaemon(true);
daemon.start();
```

## 8. Thread Safety

To ensure data consistency when multiple threads access shared data, Java provides various mechanisms for **thread safety**, such as synchronization, atomic classes (`AtomicInteger`, etc.), and explicit locks (`ReentrantLock`).

## 9. Thread States

Java threads can exist in several states, which represent their current activity and resource usage. These states are:
- **New**: When a thread is created but not yet started.
- **Runnable**: When the thread is ready to run but waiting for CPU resources.
- **Blocked**: When the thread is waiting to acquire a monitor lock to enter a synchronized block or method.
- **Waiting**: When a thread is waiting indefinitely for another thread to perform a specific action.
- **Timed Waiting**: When a thread is waiting for another thread to perform an action within a specified time.
- **Terminated**: When the thread has completed execution or was stopped.

## 10. Exception Handling in Threads

When a thread throws an unhandled exception, it will stop execution. However, Java provides mechanisms to handle such exceptions:
- **`Thread.UncaughtExceptionHandler`**: Allows you to set a custom handler for any unhandled exceptions that occur in a thread.
```java
class MyExceptionHandler implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("Exception occurred in thread: " + t.getName());
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            throw new RuntimeException("Thread Exception");
        });
        t.setUncaughtExceptionHandler(new MyExceptionHandler());
        t.start();
    }
}
```

## Summary

- **Java Threads** allow concurrent execution of tasks in a program.
- There are multiple ways to create and manage threads, either by extending the `Thread` class or implementing the `Runnable` interface.
- Proper synchronization is required when dealing with shared resources across threads to prevent race conditions.
- Thread pools and concurrency utilities, such as `ExecutorService`, help manage multiple threads efficiently.
- Daemon threads run in the background and terminate when user threads are finished.
- Ensuring thread safety is crucial when multiple threads operate on shared data.

For more detailed information on Java threads, refer to the [Java Documentation](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html).
