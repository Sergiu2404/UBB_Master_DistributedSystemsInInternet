# **Spring Annotations**

Spring Boot made configuring Spring easier with its auto-configuration feature.
Next, we’ll explore the annotations from the *org.springframework.boot.autoconfigure* and *org.springframework.boot.autoconfigure.condition* packages.

---

### 1. `@SpringBootApplication`


This is the **entry point** of a Spring Boot application. It’s a **composed annotation** that includes:

| Annotation | Purpose |
|------------|---------|
| `@Configuration` | Marks the class as a source of bean definitions |
| `@EnableAutoConfiguration` | Triggers Spring Boot’s auto-configuration |
| `@ComponentScan` | Scans the package for Spring-managed components |

### Usage
```java
@SpringBootApplication
public class VehicleFactoryApplication {
    public static void main(String[] args) {
        SpringApplication.run(VehicleFactoryApplication.class, args);
    }
}
```


### 2. `@EnableAutoConfiguration`
`@EnableAutoConfiguration`, as its name says, enables auto-configuration. It means that Spring Boot looks for 
auto-configuration beans on its classpath and automatically applies them.
Note, that we have to use this annotation with `@Configuration`:

```java
@Configuration
@EnableAutoConfiguration
class VehicleFactoryConfig {}
```

## 4. Auto-Configuration Conditions
Usually, when we write our custom auto-configurations, we want Spring to use them conditionally. We can achieve this with the annotations in this section.

We can place the annotations in this section on @Configuration classes or @Bean methods.


### 4.1. `@ConditionalOnClass` and `@ConditionalOnMissingClass`

Using these conditions, Spring will only use the marked auto-configuration bean if the class in the annotation’s argument is present/absent:

```java
@Configuration
@ConditionalOnClass(DataSource.class)
class MySQLAutoconfiguration {
    //...
}
```


### 4.2 `@ConditionalOnBean` and `@ConditionalOnMissingBean`

We can use these annotations when we want to define conditions based on the presence or absence of a specific bean:

```java
@Bean
@ConditionalOnBean(name = "dataSource")
LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        // ...
        }
```


### 4.3. `@ConditionalOnProperty`

With this annotation, we can make conditions on the values of properties:

```java
@Bean
@ConditionalOnProperty(
        name = "usemysql",
        havingValue = "local"
)
DataSource dataSource() {
        // ...
        }
```


### 4.4. `@ConditionalOnResource`

We can make Spring to use a definition only when a specific resource is present:

```java
@ConditionalOnResource(resources = "classpath:mysql.properties")
Properties additionalProperties() {
        // ...
        }
```


### 4.5. `@ConditionalOnWebApplication` and `@ConditionalOnNotWebApplication`

With these annotations, we can create conditions based on if the current application is or isn’t a web application:

```java
@ConditionalOnWebApplication
HealthCheckController healthCheckController() {
        // ...
        }
```


### 4.6. `@ConditionalExpression`

We can use this annotation in more complex situations. Spring will use the marked definition when the SpEL expression is evaluated to true:

```java
@Bean
@ConditionalOnExpression("${usemysql} && ${mysqlserver == 'local'}")
DataSource dataSource() {
        // ...
        }
```


### 4.7. `@Conditional`

For even more complex conditions, we can create a class evaluating the custom condition. We tell Spring to use this custom condition with `@Conditional`:

```java
@Conditional(HibernateCondition.class)
Properties additionalProperties() {
        //...
        }
```

