
# EJB Annotations 

Enterprise JavaBeans (EJB) annotations in Java are used to simplify the development of EJB components by reducing configuration through XML and enabling declarative control over enterprise features such as transaction management, security, and lifecycle callbacks. Here are some commonly used EJB annotations:

### 1. `@Stateless`
Used to define a stateless session bean, which does not maintain any client state between calls.
```java
import javax.ejb.Stateless;

@Stateless
public class StatelessBean {
    public String processOrder() {
        return "Order processed";
    }
}
```

### 2. `@Stateful`
Defines a stateful session bean, which maintains state information across multiple method calls.
```java
import javax.ejb.Stateful;

@Stateful
public class ShoppingCartBean {
    private List<String> cartItems = new ArrayList<>();
    public void addItem(String item) { cartItems.add(item); }
}
```

### 3. `@Singleton`
Indicates a singleton session bean, where only one instance of the bean is created and shared.
```java
import javax.ejb.Singleton;

@Singleton
public class SingletonService {
    private int hitCounter = 0;
    public int increment() { return ++hitCounter; }
}
```

### 4. `@MessageDriven`
Defines a message-driven bean (MDB), which processes messages asynchronously from a message queue or topic.
```java
import javax.ejb.MessageDriven;
import javax.jms.Message;
import javax.jms.MessageListener;

@MessageDriven
public class NotificationListener implements MessageListener {
    public void onMessage(Message message) {
        // Process incoming message
    }
}
```

### 5. `@EJB`
Used for dependency injection to inject one EJB into another class.
```java
import javax.ejb.EJB;

public class OrderService {
    @EJB
    private PaymentProcessor paymentProcessor;
}
```

### 6. `@Schedule` (Timer Service)
Defines scheduled tasks within an EJB, allowing periodic execution of business logic.
```java
import javax.ejb.Schedule;
import javax.ejb.Singleton;

@Singleton
public class Scheduler {
    @Schedule(hour = "*", minute = "*/5", persistent = false)
    public void generateReports() {
        // Code to run every 5 minutes
    }
}
```

### 7. `@TransactionManagement`
Specifies the type of transaction management for an EJB (either `BEAN` or `CONTAINER`).
```java
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;

@Stateless
@TransactionManagement(TransactionManagementType.CONTAINER)
public class AccountService {
    // Transactional methods
}
```

### 8. `@RolesAllowed`
Controls security access for specific roles on EJB methods.
```java
import javax.annotation.security.RolesAllowed;

@Stateless
public class BankService {
    @RolesAllowed("ADMIN")
    public void approveLoan() {
        // Admin-only action
    }
}
```

### 9. `@PreDestroy`, `@PostConstruct`, `@PrePassivate`, and `@PostActivate`
These are lifecycle annotations for session beans.
```java
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Stateless
public class OrderProcessor {
    @PostConstruct
    public void initialize() {
        // Initialization code
    }

    @PreDestroy
    public void cleanup() {
        // Cleanup code before removal
    }
}
```
### 10. `@Remote`
The `@Remote` annotation is used to mark an interface as a remote business interface, allowing the EJB to be called from remote clients. This enables clients outside the application server (such as different JVMs or physical locations) to access the EJB over the network.

```java
import javax.ejb.Remote;

@Remote
public interface OrderServiceRemote {
    String placeOrder(String item);
}

import javax.ejb.Stateless;

@Stateless
public class OrderService implements OrderServiceRemote {
    public String placeOrder(String item) {
        return "Order for " + item + " placed successfully.";
    }
}
```

### 11. `@Local` 

The `@Local` annotation is used in EJB 3.x to define a local business interface for an EJB (Enterprise JavaBean). A **local interface** is meant for EJBs that will be accessed within the same JVM (Java Virtual Machine), meaning there is no need for remote communication between the client and the EJB.

Local EJBs are efficient for communication within the same application or server, as they avoid the overhead of network calls and RMI (Remote Method Invocation).

#### Key Features of `@Local` Annotation:
- **Local Access**: Defines business methods that can be called locally within the same JVM.
- **No Network Communication**: Eliminates network overhead, making local calls faster.
- **Simpler**: Does not require RMI or remote communication setup.

#### Example: Using `@Local` Annotation

#### Step 1: Define the Local Business Interface
The local interface defines the business logic of the EJB. It is annotated with `@Local`.

```java
import javax.ejb.Local;

@Local
public interface OrderServiceLocal {
    void placeOrder(String orderId);
}
```


### 12. `@ConcurrencyManagement`
Controls how concurrency is handled for Singleton session beans. You can choose between container-managed and bean-managed concurrency.

- CONTAINER (default): The container controls concurrent access. You can use `@Lock` to declare read/write semantics.
- BEAN: You are responsible for thread-safety (synchronization). `@Lock` cannot be used.

Short example (container-managed):
```java
import jakarta.ejb.Singleton;
import jakarta.ejb.Startup;
import jakarta.ejb.ConcurrencyManagement;
import jakarta.ejb.ConcurrencyManagementType;

@Singleton
@Startup
@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)
public class ConfigCache {
    // container will guard concurrent access; see @Lock on methods below
}
```

Short example (bean-managed):
```java
import jakarta.ejb.Singleton;
import jakarta.ejb.ConcurrencyManagement;
import jakarta.ejb.ConcurrencyManagementType;

@Singleton
@ConcurrencyManagement(ConcurrencyManagementType.BEAN)
public class CounterService {
    private int value;
    public synchronized int increment() { // you must do your own synchronization
        return ++value;
    }
}
```

### 13. `@Lock`
Defines the locking semantics for methods in a Singleton EJB when using container-managed concurrency.

- `LockType.READ`: Multiple concurrent callers are allowed as long as no WRITE lock is held.
- `LockType.WRITE`: Exclusive access; blocks other READ/WRITE calls until the method completes.

You can put `@Lock` on the class to define a default, and override per method.

Short example:
```java
import jakarta.ejb.Singleton;
import jakarta.ejb.ConcurrencyManagement;
import jakarta.ejb.ConcurrencyManagementType;
import jakarta.ejb.Lock;
import jakarta.ejb.LockType;

@Singleton
@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)
@Lock(LockType.READ) // default for all methods unless overridden
public class CountryStateRegistry {
    private final Map<String, List<String>> data = new java.util.concurrent.ConcurrentHashMap<>();

    public List<String> getStates(String country) { // READ lock (shared)
        return data.get(country);
    }

    @Lock(LockType.WRITE) // WRITE lock (exclusive)
    public void setStates(String country, List<String> states) {
        data.put(country, new java.util.ArrayList<>(states));
    }
}
```

Note: `@Lock` is only applicable when `@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)` is used.

### Additional Notes
EJB annotations significantly simplify EJB usage and are compatible with Java EE and Jakarta EE application servers. 
Each annotation helps in structuring business logic, improving application scalability, and managing application state 
across distributed environments.
